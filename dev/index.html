<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · JSON3.jl</title><meta name="title" content="Home · JSON3.jl"/><meta property="og:title" content="Home · JSON3.jl"/><meta property="twitter:title" content="Home · JSON3.jl"/><meta name="description" content="Documentation for JSON3.jl."/><meta property="og:description" content="Documentation for JSON3.jl."/><meta property="twitter:description" content="Documentation for JSON3.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>JSON3.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Getting-Started"><span>Getting Started</span></a></li><li><a class="tocitem" href="#Builtin-types"><span>Builtin types</span></a></li><li><a class="tocitem" href="#Struct-API"><span>Struct API</span></a></li><li><a class="tocitem" href="#Generated-Types"><span>Generated Types</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/quinnj/JSON3.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/quinnj/JSON3.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="JSON3.jl-Documentation"><a class="docs-heading-anchor" href="#JSON3.jl-Documentation">JSON3.jl Documentation</a><a id="JSON3.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#JSON3.jl-Documentation" title="Permalink"></a></h1><ul><li><a href="#JSON3.jl-Documentation">JSON3.jl Documentation</a></li><li class="no-marker"><ul><li><a href="#Getting-Started">Getting Started</a></li><li class="no-marker"><ul><li><a href="#Examples">Examples</a></li><li class="no-marker"><ul><li><a href="#Basic-reading-and-writing">Basic reading and writing</a></li><li><a href="#Write-with-pretty-printing">Write with pretty printing</a></li><li><a href="#Read-and-write-from/to-a-file">Read and write from/to a file</a></li><li><a href="#Write-pretty-JSON-to-a-file">Write pretty JSON to a file</a></li><li><a href="#Read-JSON-into-a-type">Read JSON into a type</a></li><li><a href="#Read-JSON-into-an-already-instantiated-struct">Read JSON into an already instantiated struct</a></li><li><a href="#Mutating-read-JSON">Mutating read-JSON</a></li><li><a href="#Generate-a-type-from-your-JSON">Generate a type from your JSON</a></li><li><a href="#Read-in-a-date">Read in a date</a></li><li><a href="#Read-a-quoted-number">Read a quoted number</a></li></ul></li><li><a href="#API">API</a></li><li><a href="#In-Relation-to-Other-JSON-Packages">In Relation to Other JSON Packages</a></li><li class="no-marker"><ul><li><a href="#JSON.jl">JSON.jl</a></li><li><a href="#JSONTables.jl">JSONTables.jl</a></li></ul></li></ul></li><li><a href="#Builtin-types">Builtin types</a></li><li><a href="#Struct-API">Struct API</a></li><li class="no-marker"><ul><li><a href="#DataTypes">DataTypes</a></li><li><a href="#Interface-Types">Interface Types</a></li><li class="no-marker"><ul><li><a href="#StructTypes.DictType">StructTypes.DictType</a></li><li><a href="#StructTypes.ArrayType">StructTypes.ArrayType</a></li><li><a href="#StructTypes.StringType">StructTypes.StringType</a></li><li><a href="#StructTypes.NumberType">StructTypes.NumberType</a></li><li><a href="#StructTypes.BoolType">StructTypes.BoolType</a></li><li><a href="#StructTypes.NullType">StructTypes.NullType</a></li><li><a href="#JSON3.RawType">JSON3.RawType</a></li></ul></li><li><a href="#AbstractTypes">AbstractTypes</a></li><li><a href="#Parametric-types">Parametric types</a></li></ul></li><li><a href="#Generated-Types">Generated Types</a></li><li class="no-marker"><ul><li><a href="#API-2">API</a></li></ul></li></ul></li></ul><h2 id="Getting-Started"><a class="docs-heading-anchor" href="#Getting-Started">Getting Started</a><a id="Getting-Started-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-Started" title="Permalink"></a></h2><blockquote><p>Yet another JSON package for Julia; this one is for speed and slick struct mapping</p></blockquote><p>JSON3 provides two main functions: <a href="#JSON3.read"><code>JSON3.read</code></a> and <a href="#JSON3.write"><code>JSON3.write</code></a>.  These allow, in the basic case, reading a JSON string into a <a href="#JSON3.Object"><code>JSON3.Object</code></a> or <a href="#JSON3.Array"><code>JSON3.Array</code></a>, which allow for dot or bracket indexing and can be copied into base <code>Dict</code>s or <code>Vector</code>s if needed.  The slick struct mapping allows reading a JSON string directly into (almost) any type you wish and then writing directly from those types into JSON as well.</p><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><h4 id="Basic-reading-and-writing"><a class="docs-heading-anchor" href="#Basic-reading-and-writing">Basic reading and writing</a><a id="Basic-reading-and-writing-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-reading-and-writing" title="Permalink"></a></h4><pre><code class="language-julia hljs">json_string = &quot;&quot;&quot;{&quot;a&quot;: 1, &quot;b&quot;: &quot;hello, world&quot;}&quot;&quot;&quot;

hello_world = JSON3.read(json_string)

# can access the fields with dot or bracket notation
println(hello_world.b)
println(hello_world[&quot;a&quot;])

JSON3.write(hello_world)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;{\&quot;a\&quot;:1,\&quot;b\&quot;:\&quot;hello, world\&quot;}&quot;</code></pre><h4 id="Write-with-pretty-printing"><a class="docs-heading-anchor" href="#Write-with-pretty-printing">Write with pretty printing</a><a id="Write-with-pretty-printing-1"></a><a class="docs-heading-anchor-permalink" href="#Write-with-pretty-printing" title="Permalink"></a></h4><pre><code class="language-julia hljs">json_string = &quot;&quot;&quot;{&quot;a&quot;: 1, &quot;b&quot;: &quot;hello, world&quot;}&quot;&quot;&quot;

hello_world = JSON3.read(json_string)
JSON3.pretty(hello_world)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">{
    &quot;a&quot;: 1,
    &quot;b&quot;: &quot;hello, world&quot;
}</code></pre><p>The alignment of the string produced  by <code>JSON3.pretty</code> can be controlled by passing an <a href="#JSON3.AlignmentContext"><code>JSON3.AlignmentContext</code></a> to <code>JSON3.pretty</code>. To align each level at the <code>:</code> Symbol and indent each new level by 2 additional spaces, use</p><pre><code class="language-julia hljs">json_string = &quot;&quot;&quot;{&quot;a&quot;:&quot;abc&quot;,&quot;aaaaaaaaaaaaaa&quot;:{&quot;a&quot;:&quot;abc&quot;,&quot;aaaaaaaaaaaaaa&quot;:&quot;abc&quot;},&quot;c&quot;:&quot;abc&quot;}&quot;&quot;&quot;;
JSON3.pretty(JSON3.read(json_string), JSON3.AlignmentContext(alignment=:Colon, indent=2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">{
                &quot;a&quot;: &quot;abc&quot;,
   &quot;aaaaaaaaaaaaaa&quot;: {
                                     &quot;a&quot;: &quot;abc&quot;,
                        &quot;aaaaaaaaaaaaaa&quot;: &quot;abc&quot;
                     },
                &quot;c&quot;: &quot;abc&quot;
}</code></pre><p>to left align the JSON string and indent each new level by 4 additional spaces (this is also the default) use</p><pre><code class="language-julia hljs">json_string = &quot;&quot;&quot;{&quot;a&quot;:&quot;abc&quot;,&quot;aaaaaaaaaaaaaa&quot;:{&quot;a&quot;:&quot;abc&quot;,&quot;aaaaaaaaaaaaaa&quot;:&quot;abc&quot;},&quot;c&quot;:&quot;abc&quot;}&quot;&quot;&quot;;
JSON3.pretty(JSON3.read(json_string), JSON3.AlignmentContext(alignment=:Left, indent=4))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">{
    &quot;a&quot;: &quot;abc&quot;,
    &quot;aaaaaaaaaaaaaa&quot;: {
        &quot;a&quot;: &quot;abc&quot;,
        &quot;aaaaaaaaaaaaaa&quot;: &quot;abc&quot;
    },
    &quot;c&quot;: &quot;abc&quot;
}</code></pre><h4 id="Read-and-write-from/to-a-file"><a class="docs-heading-anchor" href="#Read-and-write-from/to-a-file">Read and write from/to a file</a><a id="Read-and-write-from/to-a-file-1"></a><a class="docs-heading-anchor-permalink" href="#Read-and-write-from/to-a-file" title="Permalink"></a></h4><pre><code class="language-jl hljs">json_string = read(&quot;my_file.json&quot;, String)

hello_world = JSON3.read(json_string)

open(&quot;my_new_file.json&quot;, &quot;w&quot;) do io
    JSON3.write(io, hello_world)
end</code></pre><h4 id="Write-pretty-JSON-to-a-file"><a class="docs-heading-anchor" href="#Write-pretty-JSON-to-a-file">Write pretty JSON to a file</a><a id="Write-pretty-JSON-to-a-file-1"></a><a class="docs-heading-anchor-permalink" href="#Write-pretty-JSON-to-a-file" title="Permalink"></a></h4><pre><code class="language-jl hljs">hello_world = Dict(&quot;a&quot; =&gt; Dict(&quot;b&quot; =&gt; 1, &quot;c&quot; =&gt; 2), &quot;b&quot; =&gt; Dict(&quot;c&quot; =&gt;3, &quot;d&quot; =&gt; 4))

open(&quot;my_new_file.json&quot;, &quot;w&quot;) do io
    JSON3.pretty(io, hello_world)
end</code></pre><h4 id="Read-JSON-into-a-type"><a class="docs-heading-anchor" href="#Read-JSON-into-a-type">Read JSON into a type</a><a id="Read-JSON-into-a-type-1"></a><a class="docs-heading-anchor-permalink" href="#Read-JSON-into-a-type" title="Permalink"></a></h4><p>See more details on the types that are provided and how to customize parsing <a href="#Struct-API">below</a>.</p><pre><code class="language-julia hljs">using StructTypes

json_string = &quot;&quot;&quot;{&quot;a&quot;: 1, &quot;b&quot;: &quot;hello, world&quot;}&quot;&quot;&quot;

struct MyType
    a::Int
    b::String
end

StructTypes.StructType(::Type{MyType}) = StructTypes.Struct()

hello_world = JSON3.read(json_string, MyType)

println(hello_world)

JSON3.write(hello_world)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;{\&quot;a\&quot;:1,\&quot;b\&quot;:\&quot;hello, world\&quot;}&quot;</code></pre><h4 id="Read-JSON-into-an-already-instantiated-struct"><a class="docs-heading-anchor" href="#Read-JSON-into-an-already-instantiated-struct">Read JSON into an already instantiated struct</a><a id="Read-JSON-into-an-already-instantiated-struct-1"></a><a class="docs-heading-anchor-permalink" href="#Read-JSON-into-an-already-instantiated-struct" title="Permalink"></a></h4><pre><code class="language-julia hljs">using StructTypes

Base.@kwdef mutable struct MyType
    a::Int = 0
    b::String = &quot;&quot;
    c::String = &quot;&quot;
end

StructTypes.StructType(::Type{MyType}) = StructTypes.Mutable()

t = MyType(c = &quot;foo&quot;)

json_string = &quot;&quot;&quot;{&quot;a&quot;: 1, &quot;b&quot;: &quot;hello, world&quot;}&quot;&quot;&quot;

JSON3.read!(json_string, t)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.MyType(1, &quot;hello, world&quot;, &quot;foo&quot;)</code></pre><h4 id="Mutating-read-JSON"><a class="docs-heading-anchor" href="#Mutating-read-JSON">Mutating read-JSON</a><a id="Mutating-read-JSON-1"></a><a class="docs-heading-anchor-permalink" href="#Mutating-read-JSON" title="Permalink"></a></h4><p>Note that the <code>JSON3.Object</code> and <code>JSON3.Array</code> types are immutable, and hence can&#39;t be used like a normal <code>Dict</code> or <code>Array</code> to replace or add additional values. Calling <code>copy(obj_or_arr)</code> will convert a <code>JSON3.Object</code> into a mutable <code>Dict</code> or a <code>JSON3.Array</code> into a <code>Base.Array</code>, recursively calling <code>copy</code> on any nested objects/arrays.</p><pre><code class="language-julia hljs">read_only_json = JSON3.read(&quot;{\&quot;a\&quot;: 3}&quot;)

writable_json = copy(read_only_json) # writable_json is now mutable
writable_json[:a] = 2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2</code></pre><h4 id="Generate-a-type-from-your-JSON"><a class="docs-heading-anchor" href="#Generate-a-type-from-your-JSON">Generate a type from your JSON</a><a id="Generate-a-type-from-your-JSON-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-a-type-from-your-JSON" title="Permalink"></a></h4><p>See the <a href="#Generated-Types">section on generating types</a> for more details.</p><pre><code class="language-julia hljs">using StructTypes

json_string = &quot;&quot;&quot;{&quot;a&quot;: 1, &quot;b&quot;: &quot;hello, world&quot;}&quot;&quot;&quot;

JSON3.@generatetypes json_string
hello_world = JSON3.read(json_string, JSONTypes.Root)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.JSONTypes.Root(1, &quot;hello, world&quot;)</code></pre><h4 id="Read-in-a-date"><a class="docs-heading-anchor" href="#Read-in-a-date">Read in a date</a><a id="Read-in-a-date-1"></a><a class="docs-heading-anchor-permalink" href="#Read-in-a-date" title="Permalink"></a></h4><pre><code class="language-julia hljs">using Dates

json_string = &quot;\&quot;2000-01-01\&quot;&quot;
df = dateformat&quot;yyyy-mm-dd&quot;
my_date = JSON3.read(json_string, Date; dateformat=df)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2000-01-01</code></pre><h4 id="Read-a-quoted-number"><a class="docs-heading-anchor" href="#Read-a-quoted-number">Read a quoted number</a><a id="Read-a-quoted-number-1"></a><a class="docs-heading-anchor-permalink" href="#Read-a-quoted-number" title="Permalink"></a></h4><pre><code class="language-julia hljs">using StructTypes

json_string = &quot;&quot;&quot;{&quot;a&quot;: &quot;1&quot;, &quot;b&quot;: &quot;hello, world&quot;}&quot;&quot;&quot;

struct MyType
    a::Int
    b::String
end

StructTypes.StructType(::Type{MyType}) = StructTypes.Struct()

hello_world = JSON3.read(json_string, MyType; parsequoted=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.MyType(1, &quot;hello, world&quot;)</code></pre><h3 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON3.read" href="#JSON3.read"><code>JSON3.read</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON3.read(json, [type]; kw... )</code></pre><p>Read JSON.</p><p><strong>Args</strong></p><ul><li><code>json</code>: A file, string, IO, or bytes (<code>AbstractVector{UInt8</code>) containing JSON to read</li><li><code>type</code>: Optionally, a type to read the JSON into. If not a <a href="#Builtin-types">built in type</a>, must have a &quot;struct mapping&quot; registered with <a href="#Struct-API">StructTypes.jl</a>.</li></ul><p><strong>Keyword Args</strong></p><ul><li><code>jsonlines</code>: A Bool indicating that the <code>json_str</code> contains newline delimited JSON strings, which will be read into a <code>JSON3.Array</code> of the JSON values.  See <a href="https://jsonlines.org/">jsonlines</a> for reference. [default <code>false</code>]</li><li><code>allow_inf</code>: Allow reading of <code>Inf</code> and <code>NaN</code> values (not part of the JSON standard). [default <code>false</code>]</li><li><code>dateformat</code>: A <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat"><code>DateFormat</code></a> describing the format of dates in the JSON so that they can be read into <code>Date</code>s, <code>Time</code>s, or <code>DateTime</code>s when reading into a type. [default <code>Dates.default_format(T)</code>]</li><li><code>parsequoted</code>: Accept quoted values when reading into a NumberType. [default <code>false</code>]</li><li><code>numbertype</code>: Type to parse numbers as. [default <code>nothing</code>, which parses numbers as Int if possible, Float64 otherwise]</li><li><code>ignore_extra_fields</code>: Ignore extra fields in the JSON when reading into a struct. [default <code>true</code>]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quinnj/JSON3.jl/blob/cc047e027fbd148c41d8778bcef98a93bb43cd55/src/read.jl#L12-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON3.read!" href="#JSON3.read!"><code>JSON3.read!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON3.read!(json_str, x; kw...)</code></pre><p>Incrementally update an instance of a mutable object <code>x</code> with the contents of <code>json_str</code>.  See <a href="#JSON3.read"><code>JSON3.read</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quinnj/JSON3.jl/blob/cc047e027fbd148c41d8778bcef98a93bb43cd55/src/structs.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON3.write" href="#JSON3.write"><code>JSON3.write</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON3.write([io], x; kw...)</code></pre><p>Write JSON.</p><p><strong>Args</strong></p><ul><li><code>io</code>: Optionally, an <code>IO</code> object to write the resulting JSON string to.  By default, will return a <code>String</code> if <code>io</code> is not provided.</li><li><code>x</code>: An object to serialize as JSON.  If not a <a href="#Builtin-types">built in type</a>, must have a &quot;struct mapping&quot; registered with <a href="#Struct-API">StructTypes.jl</a>.</li></ul><p><strong>Keyword Args</strong></p><ul><li><code>allow_inf</code>: Allow writing of <code>Inf</code> and <code>NaN</code> values (not part of the JSON standard). [default <code>false</code>]</li><li><code>dateformat</code>: A <a href="https://docs.julialang.org/en/v1/stdlib/Dates/#Dates.DateFormat"><code>DateFormat</code></a> describing how to format <code>Date</code>s in the object. [default <code>Dates.default_format(T)</code>]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quinnj/JSON3.jl/blob/cc047e027fbd148c41d8778bcef98a93bb43cd55/src/write.jl#L15-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON3.pretty" href="#JSON3.pretty"><code>JSON3.pretty</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON3.pretty(x, ac=JSON3.AlignmentContext(); kw...)
JSON3.pretty(io, x, ac=JSON3.AlignmentContext(); kw...)</code></pre><p>Pretty print a JSON string.</p><p><strong>Args</strong></p><ul><li><code>x</code>: A JSON string, or an object to write to JSON then pretty print.</li><li><code>io</code>: The <code>IO</code> object to write the pretty printed string to. [default <code>stdout</code>]</li><li><code>ac</code>: The <code>AlignmentContext</code> for the pretty printing. Defaults to left-aligned       with 4 spaces indent. See <a href="#JSON3.AlignmentContext"><code>JSON3.AlignmentContext</code></a> for more options.</li></ul><p><strong>Keyword Args</strong></p><p>See <a href="#JSON3.write"><code>JSON3.write</code></a> and <a href="#JSON3.read"><code>JSON3.read</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quinnj/JSON3.jl/blob/cc047e027fbd148c41d8778bcef98a93bb43cd55/src/pretty.jl#L36-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON3.@pretty" href="#JSON3.@pretty"><code>JSON3.@pretty</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON3.@pretty json_str</code></pre><p>Pretty print a JSON string or an object as JSON.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quinnj/JSON3.jl/blob/cc047e027fbd148c41d8778bcef98a93bb43cd55/src/pretty.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON3.AlignmentContext" href="#JSON3.AlignmentContext"><code>JSON3.AlignmentContext</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON3.AlignmentContext(alignment=:Left, indent=4, level=0, offset=0)</code></pre><p>Specifies the indentation of a pretty JSON string.</p><p><strong>Keyword Args</strong></p><ul><li><code>alignment</code>: A Symbol specifying the alignment type. Can be <code>:Left</code> to left-align              everything or <code>:Colon</code> to align at the <code>:</code>.</li><li><code>indent</code>: The number of spaces to indent each new level with.</li><li><code>level</code>: The indentation level.</li><li><code>offset</code>: The indentation offset.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quinnj/JSON3.jl/blob/cc047e027fbd148c41d8778bcef98a93bb43cd55/src/pretty.jl#L10-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON3.Object" href="#JSON3.Object"><code>JSON3.Object</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>An immutable (read only) struct which provides an efficient view of a JSON object. Supports the <code>AbstractDict</code> interface. See <a href="#Builtin-types">built in types</a> for more detail on why we have an <code>Object</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quinnj/JSON3.jl/blob/cc047e027fbd148c41d8778bcef98a93bb43cd55/src/JSON3.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON3.Array" href="#JSON3.Array"><code>JSON3.Array</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>An immutable (read only) struct which provides an efficient view of a JSON array. Supports the <code>AbstractArray</code> interface. See <a href="#Builtin-types">built in types</a> for more detail on why we have an <code>Array</code> type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quinnj/JSON3.jl/blob/cc047e027fbd148c41d8778bcef98a93bb43cd55/src/JSON3.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.copy" href="#Base.copy"><code>Base.copy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">copy(obj)</code></pre><p>Recursively copy <a href="#JSON3.Object"><code>JSON3.Object</code></a>s to <code>Dict</code>s and <a href="#JSON3.Array"><code>JSON3.Array</code></a>s to <code>Vector</code>s.  This copy can then be mutated if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quinnj/JSON3.jl/blob/cc047e027fbd148c41d8778bcef98a93bb43cd55/src/JSON3.jl#L130-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON3.tostring" href="#JSON3.tostring"><code>JSON3.tostring</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON3.tostring(x::Real) -&gt; String</code></pre><p>For some number types that are <code>&lt;: Real</code>, but not <code>&lt;: Integer</code> or <code>&lt;: AbstractFloat</code>, <code>tostring</code> provides an overload to convert <code>x</code> to an appropriate string representation which will be used for the JSON numeric representation. By default, <code>x</code> is converted to a <code>Float64</code> and then to a <code>String</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quinnj/JSON3.jl/blob/cc047e027fbd148c41d8778bcef98a93bb43cd55/src/write.jl#L241-L248">source</a></section></article><h3 id="In-Relation-to-Other-JSON-Packages"><a class="docs-heading-anchor" href="#In-Relation-to-Other-JSON-Packages">In Relation to Other JSON Packages</a><a id="In-Relation-to-Other-JSON-Packages-1"></a><a class="docs-heading-anchor-permalink" href="#In-Relation-to-Other-JSON-Packages" title="Permalink"></a></h3><h4 id="JSON.jl"><a class="docs-heading-anchor" href="#JSON.jl">JSON.jl</a><a id="JSON.jl-1"></a><a class="docs-heading-anchor-permalink" href="#JSON.jl" title="Permalink"></a></h4><p>While the <a href="https://github.com/JuliaIO/JSON.jl">JSON.jl</a> package has been around since the very early days of Julia, JSON3.jl aims a faster core implementation of JSON parsing (via <a href="#JSON3.read"><code>JSON3.read</code></a>), as well as better integration with custom types using the <a href="#Struct-API">Struct API</a>. Via the <a href="https://github.com/JuliaData/StructTypes.jl">StructTypes.jl</a> package, JSON3 provides numerous configurations for reading/writing custom types.</p><h4 id="JSONTables.jl"><a class="docs-heading-anchor" href="#JSONTables.jl">JSONTables.jl</a><a id="JSONTables.jl-1"></a><a class="docs-heading-anchor-permalink" href="#JSONTables.jl" title="Permalink"></a></h4><p><a href="https://github.com/JuliaData/JSONTables.jl">JSONTables.jl</a> uses JSON3 under the hood to read and write JSON sources to/from <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> compatible tables.</p><h2 id="Builtin-types"><a class="docs-heading-anchor" href="#Builtin-types">Builtin types</a><a id="Builtin-types-1"></a><a class="docs-heading-anchor-permalink" href="#Builtin-types" title="Permalink"></a></h2><p>The JSON format is made up of just a few types: Object, Array, String, Number, Bool, and Null. In the JSON3 package, there are two main interfaces for interacting with these JSON types: 1) builtin and 2) struct mapping. For builtin reading, called like <code>JSON3.read(json_string)</code>, the JSON3 package will parse a string or <code>Vector{UInt8}</code>, returning a default object that maps to the type of the JSON. For a JSON Object, it will return a <code>JSON3.Object</code> type, which acts like an immutable <code>Dict</code>, but has a more efficient view representation. For a JSON Array, it will return a <code>JSON3.Array</code> type, which acts like an immutable <code>Vector</code>, but also has a more efficient view representation. If the JSON Array has homogenous elements, the resulting <code>JSON3.Array</code> will be strongly typed accordingly. For the other JSON types (string, number, bool, and null), they are returned as Julia equivalents (<code>String</code>, <code>Int64</code> or <code>Float64</code>, <code>Bool</code>, and <code>nothing</code>).</p><p>One might wonder why custom <code>JSON3.Object</code> and <code>JSON3.Array</code> types exist instead of just returning <code>Dict</code> and <code>Vector</code> directly. JSON3 employs a novel technique <a href="https://github.com/lemire/simdjson">inspired by the simdjson project</a>, that is a semi-lazy parsing of JSON to the <code>JSON3.Object</code> or <code>JSON3.Array</code> types. The technique involves using a type-less &quot;tape&quot; to note the <em>positions</em> of objects, arrays, and strings in a JSON structure, while avoiding the cost of <em>materializing</em> such objects. For &quot;scalar&quot; types (number, bool, and null), the values are parsed immediately and stored inline in the &quot;tape&quot;. This can result in best of both worlds performance: very fast initial parsing of a JSON input, and very cheap access afterwards. It also enables efficiencies in workflows where only small pieces of a JSON structure are needed, because expensive objects, arrays, and strings aren&#39;t materialized unless accessed. One additional advantage this technique allows is strong typing of <code>JSON3.Array{T}</code>; because the type of each element is noted while parsing, the <code>JSON3.Array</code> object can then be constructed with the most narrow type possible without having to reallocate any underlying data (since all data is stored in a type-less &quot;tape&quot; anyway).</p><p>The <code>JSON3.Object</code> supports the <code>AbstractDict</code> interface, but is read-only (it represents a <em>view</em> into the JSON source input), thus it supports <code>obj[:x]</code> and <code>obj[&quot;x&quot;]</code>, as well as <code>obj.x</code> for accessing fields. It supports <code>keys(obj)</code> to see available keys in the object structure. You can call <code>length(obj)</code> to see how many key-value pairs there are, and it iterates <code>(k, v)</code> pairs like a normal <code>Dict</code>. It also supports the regular <code>get(obj, key, default)</code> family of methods.</p><p>The <code>JSON3.Array{T}</code> supports the <code>AbstractArray</code> interface, but like <code>JSON3.Object</code> is a <em>view</em> into the input JSON, hence is read-only. It supports normal array methods like <code>length(A)</code>, <code>size(A)</code>, iteration, and <code>A[i]</code> <code>getindex</code> methods.</p><p>If you really need <code>Dict</code>s and <code>Vector</code>s, then you can use <code>copy(x)</code> to recursively convert <code>JSON3.Object</code>s to <code>Dict</code>s and <code>JSON3.Array</code>s to <code>Vector</code>s.</p><h2 id="Struct-API"><a class="docs-heading-anchor" href="#Struct-API">Struct API</a><a id="Struct-API-1"></a><a class="docs-heading-anchor-permalink" href="#Struct-API" title="Permalink"></a></h2><p>The builtin JSON API in JSON3 is efficient and simple, but sometimes a direct mapping to a Julia structure is desirable. JSON3 uses the simple, yet powerful &quot;struct mapping&quot; techniques from the <a href="https://github.com/JuliaData/StructTypes.jl">StructTypes.jl</a> package.</p><p>In general, custom Julia types tend to be one of: 1) &quot;data types&quot;, 2) &quot;interface types&quot; and sometimes 3) &quot;abstract types&quot; with a known set of concrete subtypes or 4) &quot;custom types&quot; that just don&#39;t really fit in any other categories. Data types tend to be &quot;collection of fields&quot; kind of types; fields are generally public and directly accessible, they might also be made to model &quot;objects&quot; in the object-oriented sense. In any case, the type is &quot;nominal&quot; in the sense that it&#39;s &quot;made up&quot; of the fields it has, sometimes even if just for making it more convenient to pass them around together in functions.</p><p>Interface types, on the other hand, are characterized by <em>private</em> fields; they contain optimized representations &quot;under the hood&quot; to provide various features/functionality and are useful via interface methods implemented: iteration, <code>getindex</code>, accessor methods, etc. Many package-provided libraries or Base-provided structures are like this: <code>Dict</code>, <code>Array</code>, <code>Socket</code>, etc. For these types, their underlying fields are mostly cryptic and provide little value to users directly, and are often explictly documented as being implementation details and not to be accessed under warning of breakage.</p><p>What does all this have to do with mapping Julia structures to JSON? A lot! For data types, the most typical JSON representation is for each field name to be a JSON key, and each field value to be a JSON value. And when <em>reading</em> data types from JSON, we need to specify how to construct the Julia structure for the key-value pairs encountered while parsing. This can be considered a &quot;direct&quot; mapping of Julia struct types to JSON objects in that we try to map field to key directly. This is the &quot;data type&quot; view of json-to-Julia struct mapping.</p><p>For interface types, however, we don&#39;t want to consider the type&#39;s fields at all, since they&#39;re &quot;private&quot; and not very meaningful. For these types, an alternative API is provided where a user can specify the <code>StructTypes.StructType</code> their type most closely maps to, one of <code>StructTypes.DictType()</code>, <code>StructTypes.ArrayType()</code>, <code>StructTypes.StringType()</code>, <code>StructTypes.NumberType()</code>, <code>StructTypes.BoolType()</code>, or <code>StructTypes.NullType()</code>.</p><p>For abstract types, it can sometimes be useful when reading a JSON structure to say that it will be one of a limited set of related types, with a specific JSON key in the structure signaling which concrete type the rest of the structure represents. JSON3 uses StructTypes.jl functionality to specify a <code>StructTypes.AbstractType()</code> for a type, along with a mapping of JSON key-type values to Julia subtypes that can be used to identify the concrete type while parsing.</p><p>We briefly mentioned a 4th category above: &quot;custom types&quot;. Sometimes a type is just a &quot;wrapper&quot; around an internal type that has a well defined representation, be that data or interface. Sometimes, we&#39;re just in the middle of developing something and our structs are just not that well defined. <code>StructTypes.CustomStruct</code> provides a bit of an &quot;escape hatch&quot; of sorts in that we get explicit &quot;hooks&quot; into the pre-serialization and pre-deserialization steps when calling <code>JSON3.read(json, T)</code>. These are available via the <code>StructTypes.lower(x::T)</code> and <code>StructTypes.lowertype(::Type{T})</code> methods. The former will be called on any type with the <code>StructTypes.CustomStruct</code> trait before serializing, and then serializing will continue anew on whatever was returned, hence <code>StructTypes.lower</code> needs to return or transform <code>x::T</code> into something that also has a well-defined <code>StructType</code> trait. So our custom type <code>T</code> can essentially be serialized however we want by whatever we return from <code>StructTypes.lower</code>. <code>StructTypes.lowertype</code> works similarly, but for deserialization. We defined a mapping from our custom type to the type of object that should first be deserialized, which will then be passed to our type&#39;s <code>StructType.construct</code> method. An example of all this is:</p><pre><code class="language-julia hljs">struct Person
    id::Int
    name::String
end
StructTypes.StructType(::Type{Person}) = StructTypes.Struct()
struct PersonWrapper
    person::Person
end
StructTypes.StructType(::Type{PersonWrapper}) = StructTypes.CustomStruct()
StructTypes.lower(x::PersonWrapper) = x.person
StructTypes.lowertype(::Type{PersonWrapper}) = Person
StructTypes.construct(::Type{PersonWrapper}, x::Person) = PersonWrapper(x) # not strictly needed, because the default is `construct(T, x) = T(x)`</code></pre><h3 id="DataTypes"><a class="docs-heading-anchor" href="#DataTypes">DataTypes</a><a id="DataTypes-1"></a><a class="docs-heading-anchor-permalink" href="#DataTypes" title="Permalink"></a></h3><p>For &quot;data types&quot;, we aim to directly specify the JSON reading/writing behavior with respect to a Julia type&#39;s fields. This kind of data type can signal its struct type in a couple of ways:</p><pre><code class="language-julia hljs">StructTypes.StructType(::Type{MyType}) = StructTypes.Struct()
# or
StructTypes.StructType(::Type{MyType}) = StructTypes.Mutable()
# or assuming certain conditions
StructTypes.StructType(::Type{MyType}) = StructTypes.OrderedStruct()</code></pre><p><code>StructTypes.Struct</code> and <code>StructTypes.Mutable</code> correspond to the existing difference between Julia <code>struct</code> and <code>mutable struct</code> types: that is, immutable (<code>Struct</code>) vs. mutable (<code>Mutable</code>). <code>StructTypes.OrderedStruct()</code> is less flexible, yet more performant. For reading a <code>StructTypes.OrderedStruct()</code> from a JSON string input, each key-value pair is read in the order it is encountered in the JSON input, the keys are ignored, and the values are directly passed to the type at the end of the object parsing like <code>MyType(val1, val2, val3)</code>. Yes, the JSON specification says that Objects are specifically <em>un-ordered</em> collections of key-value pairs, but the truth is that many JSON libraries provide ways to maintain JSON Object key-value pair order when reading/writing. Because of the minimal processing done while parsing, and the &quot;trusting&quot; that the Julia type constructor will be able to handle fields being present, missing, or even extra fields that should be ignored, this is the fastest possible method for mapping a JSON input to a Julia structure. If your workflow interacts with non-Julia APIs for sending/receiving JSON, you should take care to test and confirm the use of <code>StructTypes.OrderedStruct()</code> in the cases mentioned above: what if a field is missing when parsing? what if the key-value pairs are out of order? what if there extra fields get included that weren&#39;t anticipated? If your workflow is questionable on these points, or it would be too difficult to account for these scenarios in your type constructor, it would be better to consider the <code>StructTypes.Struct</code> or <code>StructTypes.Mutable()</code> options.</p><p>The slightly less performant, yet much more robust method for directly mapping Julia struct fields to JSON objects is via <code>StructTypes.Mutable()</code>. This technique requires your Julia type to be defined, <em>at a minimum</em>, like:</p><pre><code class="language-julia hljs">mutable struct MyType
    field1
    field2
    field3
    # etc.

    MyType() = new()
end
# or if not an &quot;empty&quot; inner construct, can be empty outer constructor
MyType() = ...</code></pre><p>Note specifically that we&#39;re defining a <code>mutable struct</code> to allow field mutation, and providing a <code>MyType() = new()</code> inner constructor which constructs an &quot;empty&quot; <code>MyType</code> where isbits fields will be randomly initialized, and reference fields will be <code>#undef</code>. (Note that the constructor doesn&#39;t need to be <em>exactly</em> this (i.e. inner), but at least needs to be callable like <code>MyType()</code>. If certain fields need to be intialized or zeroed out for security, then this should be accounted for in the constructor). For these mutable types, the type will first be initizlied like <code>MyType()</code>, then JSON parsing will parse each key-value pair in a JSON object, setting the field as the key is encountered, and converting the JSON value to the appropriate field value. This flow has the nice properties of: allowing parsing success even if fields are missing in the JSON structure, and if &quot;extra&quot; fields exist in the JSON structure that aren&#39;t apart of the Julia struct&#39;s fields, they will automatically be ignored. This allows for maximum robustness when mapping Julia types to arbitrary JSON objects that may be generated via web services, other language JSON libraries, etc.</p><p><code>StructTypes.Struct</code> work similarly, but due to their immutability, fields are parsed from JSON, then passed to <code>StructTypes.construct(T, x...)</code> where <code>T</code> is our struct type, and <code>x...</code> are the fields we&#39;ve parsed from the JSON, provided <em>in field order</em>, even if the JSON had fields out of order. If fields are missing from the JSON itself, the <code>nothing</code> value will be passed for those fields, so constructors should account for the potential of missing fields by setting a default value in case of <code>nothing</code> or perhaps typeing the field like <code>Union{String, Nothing}</code> explicitly.</p><p>There are a few additional helper methods that can be utilized by these <code>StructTypes.DataType</code> types to hand-tune field reading/writing behavior:</p><ul><li><code>StructTypes.names(::Type{MyType}) = ((:field1, :json1), (:field2, :json2))</code>: provides a mapping of Julia field name to expected JSON object key name. This affects both reading and writing. When reading the <code>json1</code> key, the <code>field1</code> field of <code>MyType</code> will be set. When writing the <code>field2</code> field of <code>MyType</code>, the JSON key will be <code>json2</code>.</li><li><code>StructTypes.excludes(::Type{MyType}) = (:field1, :field2)</code>: specify fields of <code>MyType</code> to ignore when reading and writing, provided as a <code>Tuple</code> of <code>Symbol</code>s. When reading, if <code>field1</code> is encountered as a JSON key, it&#39;s value will be read, but the field will not be set in <code>MyType</code>. When writing, <code>field1</code> will be skipped when writing out <code>MyType</code> fields as key-value pairs.</li><li><code>StructTypes.omitempties(::Type{MyType}) = (:field1, :field2)</code>: specify fields of <code>MyType</code> that shouldn&#39;t be written if they are &quot;empty&quot;, provided as a <code>Tuple</code> of <code>Symbol</code>s. This only affects writing. If a field is a collection (AbstractDict, AbstractArray, etc.) and <code>isempty(x) === true</code>, then it will not be written. If a field is <code>#undef</code>, it will not be written. If a field is <code>nothing</code>, it will not be written.</li><li><code>StructTypes.keywordargs(::Type{MyType}) = (field1=(dateformat=dateformat&quot;mm/dd/yyyy&quot;,), field2=(dateformat=dateformat&quot;HH MM SS&quot;,))</code>: Specify for a <code>StructTypes.Mutable</code> <code>StructType</code> the keyword arguments by field, given as a <code>NamedTuple</code> of <code>NamedTuple</code>s, that should be passed to the <code>StructTypes.construct</code> method when deserializing <code>MyType</code>. This essentially allows defining specific keyword arguments you&#39;d like to be passed for each field in your struct. Note that keyword arguments can be passed when reading, like <code>JSON3.read(source, MyType; dateformat=...)</code> and they will be passed down to each <code>StructTypes.construct</code> method. <code>StructTypes.keywordargs</code> just allows the defining of specific keyword arguments per field.</li></ul><h3 id="Interface-Types"><a class="docs-heading-anchor" href="#Interface-Types">Interface Types</a><a id="Interface-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Interface-Types" title="Permalink"></a></h3><p>For interface types, we don&#39;t want the internal fields of a type exposed, so an alternative API is to define the closest JSON type that our custom type should map to. This is done by choosing one of the following definitions:</p><pre><code class="language-julia hljs">StructTypes.StructType(::Type{MyType}) = StructTypes.DictType()
StructTypes.StructType(::Type{MyType}) = StructTypes.ArrayType()
StructTypes.StructType(::Type{MyType}) = StructTypes.StringType()
StructTypes.StructType(::Type{MyType}) = StructTypes.NumberType()
StructTypes.StructType(::Type{MyType}) = StructTypes.BoolType()
StructTypes.StructType(::Type{MyType}) = StructTypes.NullType()
StructTypes.StructType(::Type{MyType}) = JSON3.RawType()</code></pre><p>Now we&#39;ll walk through each of these and what it means to map my custom Julia type to an interface type.</p><h4 id="StructTypes.DictType"><a class="docs-heading-anchor" href="#StructTypes.DictType">StructTypes.DictType</a><a id="StructTypes.DictType-1"></a><a class="docs-heading-anchor-permalink" href="#StructTypes.DictType" title="Permalink"></a></h4><pre><code class="nohighlight hljs">StructTypes.StructType(::Type{MyType}) = StructTypes.DictType()</code></pre><p>Declaring my type is <code>StructTypes.DictType()</code> means it should map to a JSON object of unordered key-value pairs, where keys are <code>Symbol</code> or <code>String</code>, and values are any other type (or <code>Any</code>).</p><p>Types already declared as <code>StructTypes.DictType()</code> include:</p><ul><li>Any subtype of <code>AbstractDict</code></li><li>Any <code>NamedTuple</code> type</li><li>Any <code>Pair</code> type</li></ul><p>So if your type subtypes <code>AbstractDict</code> and implements its interface, then JSON reading/writing should just work!</p><p>Otherwise, the interface to satisfy <code>StructTypes.DictType()</code> for reading is:</p><ul><li><code>MyType(x::Dict{Symbol, Any})</code>: implement a constructor that takes a <code>Dict{Symbol, Any}</code> of key-value pairs parsed from JSON</li><li><code>StructTypes.construct(::Type{MyType}, x::Dict; kw...)</code>: alternatively, you may overload the <code>StructTypes.construct</code> method for your type if defining a constructor is undesirable (or would cause other clashes or ambiguities)</li></ul><p>The interface to satisfy for writing is:</p><ul><li><code>pairs(x)</code>: implement the <code>pairs</code> iteration function (from Base) to iterate key-value pairs to be written out to JSON</li><li><code>StructTypes.keyvaluepairs(x::MyType)</code>: alternatively, you can overload the <code>StructTypes.keyvaluepairs</code> function if overloading <code>pairs</code> isn&#39;t possible for whatever reason</li></ul><h4 id="StructTypes.ArrayType"><a class="docs-heading-anchor" href="#StructTypes.ArrayType">StructTypes.ArrayType</a><a id="StructTypes.ArrayType-1"></a><a class="docs-heading-anchor-permalink" href="#StructTypes.ArrayType" title="Permalink"></a></h4><pre><code class="nohighlight hljs">StructTypes.StructType(::Type{MyType}) = StructTypes.ArrayType()</code></pre><p>Declaring my type is <code>StructTypes.ArrayType()</code> means it should map to a JSON array of ordered elements, homogenous or otherwise.</p><p>Types already declared as <code>StructTypes.ArrayType()</code> include:</p><ul><li>Any subtype of <code>AbstractArray</code></li><li>Any subtype of <code>AbstractSet</code></li><li>Any <code>Tuple</code> type</li></ul><p>So if your type already subtypes these and satifies the interface, things should just work.</p><p>Otherwise, the interface to satisfy <code>StructTypes.ArrayType()</code> for reading is:</p><ul><li><code>MyType(x::Vector)</code>: implement a constructo that takes a <code>Vector</code> argument of values and constructs a <code>MyType</code></li><li><code>StructTypes.construct(::Type{MyType}, x::Vector; kw...)</code>: alternatively, you may overload the <code>StructTypes.construct</code> method for your type if defining a constructor isn&#39;t possible</li><li>Optional: <code>Base.IteratorEltype(::Type{MyType})</code> and <code>Base.eltype(x::MyType)</code>: this can be used to signal to JSON3 that elements for your type are expected to be a single type and JSON3 will attempt to parse as such</li></ul><p>The interface to satisfy for writing is:</p><ul><li><code>iterate(x::MyType)</code>: just iteration over each element is required; note if you subtype <code>AbstractArray</code> and define <code>getindex(x::MyType, i::Int)</code>, then iteration is already defined for your type</li></ul><h4 id="StructTypes.StringType"><a class="docs-heading-anchor" href="#StructTypes.StringType">StructTypes.StringType</a><a id="StructTypes.StringType-1"></a><a class="docs-heading-anchor-permalink" href="#StructTypes.StringType" title="Permalink"></a></h4><pre><code class="nohighlight hljs">StructTypes.StructType(::Type{MyType}) = StructTypes.StringType()</code></pre><p>Declaring my type is <code>StructTypes.StringType()</code> means it should map to a JSON string value.</p><p>Types already declared as <code>StructTypes.StringType()</code> include:</p><ul><li>Any subtype of <code>AbstractString</code></li><li>The <code>Symbol</code> type</li><li>Any subtype of <code>Enum</code> (values are written with their symbolic name)</li><li>The <code>Char</code> type</li></ul><p>So if your type is an <code>AbstractString</code> or <code>Enum</code>, then things should already work.</p><p>Otherwise, the interface to satisfy <code>StructTypes.StringType()</code> for reading is:</p><ul><li><code>MyType(x::String)</code>: define a constructor for your type that takes a single String argument</li><li><code>StructTypes.construct(::Type{MyType}, x::String; kw...)</code>: alternatively, you may overload <code>StructTypes.construct</code> for your type</li><li><code>StructTypes.construct(::Type{MyType}, ptr::Ptr{UInt8}, len::Int; kw...)</code>: another option is to overload <code>StructTypes.construct</code> with pointer and length arguments, if it&#39;s possible for your custom type to take advantage of avoiding the full string materialization; note that your type should implement both <code>StructTypes.construct</code> methods, since JSON strings with escape characters in them will be fully unescaped before calling <code>StructTypes.construct(::Type{MyType}, x::String)</code>, i.e. there is no direct pointer/length method for escaped strings</li></ul><p>The interface to satisfy for writing is:</p><ul><li><code>Base.string(x::MyType)</code>: overload <code>Base.string</code> for your type to return a &quot;stringified&quot; value</li></ul><h4 id="StructTypes.NumberType"><a class="docs-heading-anchor" href="#StructTypes.NumberType">StructTypes.NumberType</a><a id="StructTypes.NumberType-1"></a><a class="docs-heading-anchor-permalink" href="#StructTypes.NumberType" title="Permalink"></a></h4><pre><code class="nohighlight hljs">StructTypes.StructType(::Type{MyType}) = StructTypes.NumberType()</code></pre><p>Declaring my type is <code>StructTypes.NumberType()</code> means it should map to a JSON number value.</p><p>Types already declared as <code>StructTypes.NumberType()</code> include:</p><ul><li>Any subtype of <code>Signed</code></li><li>Any subtype of <code>Unsigned</code></li><li>Any subtype of <code>AbstractFloat</code></li></ul><p>In addition to declaring <code>StructTypes.NumberType()</code>, custom types can also specify a specific, <em>existing</em> number type it should map to. It does this like:</p><pre><code class="language-julia hljs">StructTypes.numbertype(::Type{MyType}) = Float64</code></pre><p>In this case, I&#39;m declaring the <code>MyType</code> should map to an already-supported number type <code>Float64</code>. This means that when reading, JSON3 will first parse a <code>Float64</code> value, and then call <code>MyType(x::Float64)</code>. Note that custom types may also overload <code>StructTypes.construct(::Type{MyType}, x::Float64; kw...)</code> if using a constructor isn&#39;t possible. Also note that the default for any type declared as <code>StructTypes.NumberType()</code> is <code>Float64</code>.</p><p>Similarly for writing, JSON3 will first call <code>Float64(x::MyType)</code> before writing the resulting <code>Float64</code> value out as a JSON number.</p><h4 id="StructTypes.BoolType"><a class="docs-heading-anchor" href="#StructTypes.BoolType">StructTypes.BoolType</a><a id="StructTypes.BoolType-1"></a><a class="docs-heading-anchor-permalink" href="#StructTypes.BoolType" title="Permalink"></a></h4><pre><code class="nohighlight hljs">StructTypes.StructType(::Type{MyType}) = StructTypes.BoolType()</code></pre><p>Declaring my type is <code>StructTypes.BoolType()</code> means it should map to a JSON boolean value.</p><p>Types already declared as <code>StructTypes.BoolType()</code> include:</p><ul><li><code>Bool</code></li></ul><p>The interface to satisfy for reading is:</p><ul><li><code>MyType(x::Bool)</code>: define a constructor that takes a single <code>Bool</code> value</li><li><code>StructTypes.construct(::Type{MyType}, x::Bool; kw...)</code>: alternatively, you may overload <code>StructTypes.construct</code></li></ul><p>The interface to satisfy for writing is:</p><ul><li><code>Bool(x::MyType)</code>: define a conversion to <code>Bool</code> method</li></ul><h4 id="StructTypes.NullType"><a class="docs-heading-anchor" href="#StructTypes.NullType">StructTypes.NullType</a><a id="StructTypes.NullType-1"></a><a class="docs-heading-anchor-permalink" href="#StructTypes.NullType" title="Permalink"></a></h4><pre><code class="nohighlight hljs">StructTypes.StructType(::Type{MyType}) = StructTypes.NullType()</code></pre><p>Declaring my type is <code>StructTypes.NullType()</code> means it should map to the JSON value <code>null</code>.</p><p>Types already declared as <code>StructTypes.NullType()</code> include:</p><ul><li><code>nothing</code></li><li><code>missing</code></li></ul><p>The interface to satisfy for reading is:</p><ul><li><code>MyType()</code>: an empty constructor for <code>MyType</code></li><li><code>StructTypes.construct(::Type{MyType}, x::Nothing; kw...)</code>: alternatively, you may overload <code>StructTypes.construct</code></li></ul><p>There is no interface for writing; if a custom type is declared as <code>StructTypes.NullType()</code>, then the JSON value <code>null</code> will be written.</p><h4 id="JSON3.RawType"><a class="docs-heading-anchor" href="#JSON3.RawType">JSON3.RawType</a><a id="JSON3.RawType-1"></a><a class="docs-heading-anchor-permalink" href="#JSON3.RawType" title="Permalink"></a></h4><p><code>JSON3.RawType</code> is a <code>StructType</code> that custom types may define as their trait in order to get access to the &quot;raw value&quot; while parsing. After declaring <code>StructTypes.StructType(::Type{MyType}) = JSON3.RawType()</code>, the custom <code>MyType</code> must also define <code>StructTypes.construct(::Type{MyType}, x::JSON3.RawValue) = ...</code>. A <code>JSON3.RawValue</code> has 3 fields, <code>bytes</code>, <code>pos</code>, and <code>len</code>, corresponding to the raw byte buffer, byte position at which the raw value starts, and the length of the raw value, respectively. Users are then free to &quot;construct&quot; an instance of their <code>MyType</code> however they want from the <code>JSON3.RawValue</code>.</p><p>For serializing, i.e. <code>JSON3.write</code>, <code>MyType</code> must implement a method like <code>JSON3.rawbytes(x::MyType) = ...</code>, which must return an iterator of bytes (<code>UInt8</code>) with known length (<code>Base.IteratorSize</code> must be <code>Base.HasLength()</code> and <code>length(JSON3.rawbytes(x))</code> must work). Care must be taken in providing bytes as no additional processing or escape analysis is done, the bytes are written &quot;as-is&quot;. If bytes are written with unescaped control characters (<code>&#39;{&#39;</code>, <code>&#39;,&#39;</code>, etc.), it will result in corrupt JSON documents.</p><p>For example, suppose that you want to read a JSON number verbatim into a Julia string:</p><pre><code class="language-julia-repl hljs">julia&gt; using JSON3, StructTypes

julia&gt; struct StringNumber
       value::String
       end

julia&gt; @inline StructTypes.StructType(::Type{StringNumber}) = JSON3.RawType()

julia&gt; @inline StructTypes.construct(::Type{StringNumber}, x::JSON3.RawValue) = StringNumber(unsafe_string(pointer(x.bytes, x.pos), x.len))

julia&gt; @inline JSON3.rawbytes(x::StringNumber) = codeunits(x.value)

julia&gt; j = &quot;1.200&quot;
&quot;1.200&quot;

julia&gt; x = JSON3.read(j, StringNumber)
StringNumber(&quot;1.200&quot;)

julia&gt; JSON3.write(x)
&quot;1.200&quot;</code></pre><h3 id="AbstractTypes"><a class="docs-heading-anchor" href="#AbstractTypes">AbstractTypes</a><a id="AbstractTypes-1"></a><a class="docs-heading-anchor-permalink" href="#AbstractTypes" title="Permalink"></a></h3><p>A final, uncommon option for struct mapping is declaring:</p><pre><code class="language-julia hljs">StructTypes.StructType(::Type{MyType}) = StructTypes.AbstractType()</code></pre><p>When declaring my type as <code>StructTypes.AbstractType()</code>, you must also define <code>StructTypes.subtypes</code>, which should be a NamedTuple with subtype keys mapping to Julia subtype Type values. You may optionally define <code>StructTypes.subtypekey</code> that indicates which JSON key should be used for identifying the appropriate concrete subtype. A quick example should help illustrate proper use of this <code>StructType</code>:</p><pre><code class="language-julia hljs">abstract type Vehicle end

struct Car &lt;: Vehicle
    type::String
    make::String
    model::String
    seatingCapacity::Int
    topSpeed::Float64
end

struct Truck &lt;: Vehicle
    type::String
    make::String
    model::String
    payloadCapacity::Float64
end

StructTypes.StructType(::Type{Vehicle}) = StructTypes.AbstractType()
StructTypes.StructType(::Type{Car}) = StructTypes.Struct()
StructTypes.StructType(::Type{Truck}) = StructTypes.Struct()
StructTypes.subtypekey(::Type{Vehicle}) = :type
StructTypes.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)

car = JSON3.read(&quot;&quot;&quot;
{
    &quot;type&quot;: &quot;car&quot;,
    &quot;make&quot;: &quot;Mercedes-Benz&quot;,
    &quot;model&quot;: &quot;S500&quot;,
    &quot;seatingCapacity&quot;: 5,
    &quot;topSpeed&quot;: 250.1
}&quot;&quot;&quot;, Vehicle)</code></pre><p>Here we have a <code>Vehicle</code> type that is defined as a <code>StructTypes.AbstractType()</code>. We also have two concrete subtypes, <code>Car</code> and <code>Truck</code>. In addition to the <code>StructType</code> definition, we also define <code>StructTypes.subtypekey(::Type{Vehicle}) = :type</code>, which signals to JSON3 that, when parsing a JSON structure, when it encounters the <code>type</code> key, it should use the value, in our example it&#39;s <code>car</code>, to discover the appropriate concrete subtype to parse the structure as, in this case <code>Car</code>. The mapping of JSON subtype key value to Julia Type is defined in our example via <code>StructTypes.subtypes(::Type{Vehicle}) = (car=Car, truck=Truck)</code>. Thus, <code>StructTypes.AbstractType</code> is useful when the JSON structure to read includes a &quot;subtype&quot; key-value pair that can be used to parse a specific, concrete type; in our example, parsing the structure as a <code>Car</code> instead of a <code>Truck</code>.</p><h3 id="Parametric-types"><a class="docs-heading-anchor" href="#Parametric-types">Parametric types</a><a id="Parametric-types-1"></a><a class="docs-heading-anchor-permalink" href="#Parametric-types" title="Permalink"></a></h3><p>For Julia dispatch and thereby for both <code>StructTypes</code> and <code>JSON3.jl</code> parametric types with different parameters are their own type. Consider this example where subtype of <code>data</code> depens on properties of the surrounding envelope object.</p><pre><code class="language-julia hljs">abstract type MessageTypes end
struct Envelope{MsgType &lt;: MessageTypes}
    _id :: Int
    data :: MsgType
    _type :: String
    Envelope{MsgType}(n,t, tnm) where {MsgType} = new(n,t, tnm)
end

StructTypes.StructType(::Type{Envelope}) = StructTypes.AbstractType()
StructTypes.StructType(::Type{Envelope{T}}) where T &lt;: MessageTypes  = StructTypes.Struct()
StructTypes.subtypekey(::Type{Envelope}) = :_type
StructTypes.subtypes(::Type{Envelope}) = (ping=Envelope{Ping}, pong=Envelope{Pong})

struct Ping &lt;: MessageTypes
  now::String
end
StructTypes.StructType(::Type{Ping}) = StructTypes.Struct()
  
struct Pong &lt;: MessageTypes
  now::Int
end
StructTypes.StructType(::Type{Pong}) = StructTypes.Struct()</code></pre><p>So <code>Type{Envelope}</code>, <code>Type{Envelope{Ping}}</code> and <code>Type{Envelope{Pong}}</code> are distinct Julia types which each can have their own dispatch. Here <code>Type{Envelope}</code> is choosen to be an <code>StructTypes.AbstractType()</code>. Note that <code>Envelope</code> is not an abstract type. <code>StructTypes.AbstractType()</code> makes no claims about properties of the Julia type and instead causes a subtype lookup when this type is used for deserialization. Deserializing against <code>Envelope</code> triggers a look-up of a type based one value in the field <code>_type</code> in this example.</p><pre><code class="language-julia hljs">  @assert JSON3.read(&quot;&quot;&quot;{&quot;_id&quot;:1,&quot;data&quot;:{&quot;now&quot;:2023},&quot;_type&quot;:&quot;pong&quot;}&quot;&quot;&quot;, Envelope) isa Envelope{Pong}
  @assert JSON3.read(&quot;&quot;&quot;{&quot;_id&quot;:1,&quot;data&quot;:{&quot;now&quot;:&quot;2023&quot;},&quot;_type&quot;:&quot;ping&quot;}&quot;&quot;&quot;, Envelope) isa Envelope{Ping}</code></pre><p>If given a parametric types we want define all subtypes to be a <code>StructTypes.StructType</code> <code>&lt;:</code> is useful.</p><pre><code class="language-julia hljs">struct MyParametricType{T}
    t::T
    MyParametricType{T}(t) where {T} = new(t)
end
MyParametricType(t::T) where {T} = MyParametricType{T}(t)

x = MyParametricType(1)

StructTypes.StructType(::Type{&lt;:MyParametricType}) = StructTypes.Struct() </code></pre><p>This match all possible parametric types <code>MyParametricType{T}</code>. When deserializing, the type parameter(s) should be provided:</p><pre><code class="language-julia hljs">JSON3.read(json_string, MyParametricType{Int}) # NOT JSON3.read(json_string, MyParametricType)</code></pre><p>In the previous example <code>Envelope</code> was ultimatetly resolved to a fully parametrized type.</p><h2 id="Generated-Types"><a class="docs-heading-anchor" href="#Generated-Types">Generated Types</a><a id="Generated-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Generated-Types" title="Permalink"></a></h2><p>JSON3 has the ability to generate types from sample JSON, which then can be used to parse JSON into. Inspired by the <a href="http://tomasp.net/academic/papers/fsharp-data/fsharp-data.pdf">F# type provider</a>.</p><pre><code class="language-julia hljs">JSON3.@generatetypes sample :MyModule
JSON3.read(full_json, MyModule.Root)

# or if sample is an array of objects
JSON3.read(full_json, Vector{MyModule.Root})</code></pre><p>The <a href="#JSON3.@generatetypes"><code>JSON3.@generatetypes</code></a> macro takes a JSON string or file name, generates a raw type from it, then parses that raw type into a series of mutable structs, which are then evaluated in a module (default <code>JSONTypes</code>) in the local scope.  Alternately, the <a href="#JSON3.writetypes"><code>JSON3.writetypes</code></a> function can be used to perform these same steps, but instead write the generated module to file.</p><pre><code class="language-julia hljs"># writes a module called JSONTypes with the root struct Root as mutable
JSON3.writetypes(sample, &quot;json_types.jl&quot;)

# write the same module, but with custom names and immutable
JSON3.writetypes(sample, &quot;json_types.jl&quot;; module_name=:MyModule, root_name=:ABC, mutable=false)

# these files can then be edited as needed (perhaps to prune the imported json)
include(&quot;json_types.jl&quot;)</code></pre><h3 id="API-2"><a class="docs-heading-anchor" href="#API-2">API</a><a class="docs-heading-anchor-permalink" href="#API-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON3.generatetypes" href="#JSON3.generatetypes"><code>JSON3.generatetypes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON3.generatetypes(json, module_name; mutable=true, root_name=:Root)</code></pre><p>Convenience function to go from a json string, an array of json strings, or a file name to an AST with a module of structs.</p><p>Performs the following:</p><ol><li>If the JSON is a file, read to string</li><li>Call <code>JSON3.read</code> on the JSON string</li><li>Get the &quot;raw type&quot; from <a href="#JSON3.generate_type"><code>generate_type</code></a></li><li>Parse the &quot;raw type&quot; into a vector of <code>Expr</code> (<a href="#JSON3.generate_exprs"><code>generate_exprs</code></a>)</li><li>Generate an AST with the module containg the structs (<a href="#JSON3.generate_struct_type_module"><code>generate_struct_type_module</code></a>)</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quinnj/JSON3.jl/blob/cc047e027fbd148c41d8778bcef98a93bb43cd55/src/gentypes.jl#L440-L451">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON3.@generatetypes" href="#JSON3.@generatetypes"><code>JSON3.@generatetypes</code></a> — <span class="docstring-category">Macro</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON3.@generatetypes json [module_name]</code></pre><p>Evaluate the result of the <a href="#JSON3.generatetypes"><code>generatetypes</code></a> function in the current scope.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quinnj/JSON3.jl/blob/cc047e027fbd148c41d8778bcef98a93bb43cd55/src/gentypes.jl#L480-L484">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON3.writetypes" href="#JSON3.writetypes"><code>JSON3.writetypes</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON3.writetypes(json, file_name; module_name=:JSONTypes, root_name=:Root, mutable=true)</code></pre><p>Write the result of the <a href="#JSON3.generatetypes"><code>generatetypes</code></a> function to file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quinnj/JSON3.jl/blob/cc047e027fbd148c41d8778bcef98a93bb43cd55/src/gentypes.jl#L494-L498">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON3.generate_type" href="#JSON3.generate_type"><code>JSON3.generate_type</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON3.generate_type(json)</code></pre><p>Given a JSON3 Object or Array, return a &quot;raw type&quot; from it.  A raw type is typically a <code>NamedTuple</code>, which can contain further nested <code>NamedTuples</code>, concrete, <code>Array</code>, or <code>Union</code> types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quinnj/JSON3.jl/blob/cc047e027fbd148c41d8778bcef98a93bb43cd55/src/gentypes.jl#L97-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON3.generate_exprs" href="#JSON3.generate_exprs"><code>JSON3.generate_exprs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON3.generate_exprs(raw_type; root_name=:Root, mutable=true)</code></pre><p>Generate a vector of <code>Expr</code> from a &quot;raw_type&quot;.  This will un-nest any sub-types within the root type.</p><p>The name of the root type is from the <code>name</code> variable (default :Root), then nested types are named from the key that they live under in the JSON.  The key is transformed to be pascal case and singular.</p><p>If <code>mutable</code> is <code>true</code>, an empty constructor is included in the struct definition. This allows the mutable structs to be used with <code>StructTypes.Mutable()</code> out of the box.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quinnj/JSON3.jl/blob/cc047e027fbd148c41d8778bcef98a93bb43cd55/src/gentypes.jl#L316-L324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON3.write_exprs" href="#JSON3.write_exprs"><code>JSON3.write_exprs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON3.write_exprs(expr, f)</code></pre><p>Write an <code>Expr</code> or <code>Vector{Expr}</code> to file.  Formatted so that it can be used with <code>include</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quinnj/JSON3.jl/blob/cc047e027fbd148c41d8778bcef98a93bb43cd55/src/gentypes.jl#L275-L279">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="JSON3.generate_struct_type_module" href="#JSON3.generate_struct_type_module"><code>JSON3.generate_struct_type_module</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">JSON3.generate_struct_type_module(exprs, module_name)</code></pre><p>Given a vector of <code>exprs</code> (output of <a href="#JSON3.generate_exprs"><code>generate_exprs</code></a>), return an <code>Expr</code> containing the AST for a module with name <code>module_name</code>.  The module will map all types to the appropriate <code>StructType</code>, so the result can immediately used with <code>JSON3.read(json, T)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/quinnj/JSON3.jl/blob/cc047e027fbd148c41d8778bcef98a93bb43cd55/src/gentypes.jl#L418-L422">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Friday 23 May 2025 13:19">Friday 23 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
